** ex1
*** ?                                                            :no_compris:
"scan_j[i] = −1" pourquoi il y a 1 "-1" dans le tableau. C'est la valeur initial avant update?
*** (b)
**** on veut montrer que "Pour j != i, scan_j[i] = i ou scan_j[i] = −1"
*** Pour j != i, scan_j ⊆ scan_i ou scan_i ⊆ scan_j 
**** scan_j ⊆ scan_i
<=>  pour tout (i,j),  (scan_j[i] != −1) ==>  (scan_j[i] = scan_i[i])
<=>  pour tout (i,j), ¬ (scan_j[i] != −1)  ∨ (scan_j[i] = scan_i[i])

a) Par l'absurde: scani[i] = -1 
donc il n'y a pas eu de update(i) auparavant par la thread i OR il y en a bien eu un et l'opération est atomique et aucune autre thread ne peut venir modifier la valeur à la case i.

Donc a est VRAIE

b) Deux cas: 
si le scan de la thread j s'est exécutée avant le update de la thread i alors le scanj[i] donnera -1. 
Sinon il donnera i
VRAIE

c) Voici un ordre d'exécution Contre exemple:
 ti.update(i);
 ti.scan();
 tj.update(j)
 tj.scan()
 FAUX

 d)
Contre exemple:
 ti.update(i)
 tj.update(j)
 ti.scan()
 tj.scan()
 FAUX

 e) 

i différent de j et les opérations sont atomiques donc:
A v B
Pour que ce soit faux => A faux ET B faux

A faux => scanj[i]= -1 donc le j a fait scan donc il a fait update
donc B est forcément vraie
ET VICE VERSA:
B faux => A vrai

LE TOUT EST VRAI

f) scanj < scani <=> scanj[i]!=-1 => scanj[i]=scani[i]
 scanj[i]!=-1 => scanj[i]=i donc scanj[i]=scani[i]


( la relation ⊆ est A ⊆ B si et seulement si A[i] != −1 alors A[i] = B[i])
** ex2
*** 2
**** (a)
***** Dans quelle cas une exécution ne termine pas?
un thread A qui fait scan()

Si il existe toujours un processus qui update() la mémoire lors de la double lecture de A. Ainsi, le thread A ne peut jamais se terminer.
***** Quelle condition de progression assure cette implémentation?
****** l'algorithme n'est pas wait-free
car la progression de scan() depend que les autres threads ne change pas la mémoire pendant sa double lecture
****** l'algorithme est non bloquant
car
- soit il retourne le resultat
- soit il est en boucle continue en attendant le bon moment pour sortir de la boucle

 il y a pas utilisation de mutex, il ne se bloque pas sur une instruction
****** l'algorithme est obstruction-free
car 
- soit il retourne le resultat
- soit il est en boucle continue en attendant le bon moment pour sortir de la boucle
**** (b) quel diff entre AtomicStampedReference<T> et Stamped<T> :no_compris:
pas de spec is given for Stamped<T>
**** c [Ljava.lang.Object; cannot be cast to [LAtomicStampedReference; :no_compris:
*** Afin de réaliser une implémentation atomique                 :no_compris:
en quoi c'est atomique
